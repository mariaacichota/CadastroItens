unit Order.Tests;

interface

uses
  DUnitX.TestFramework, FireDAC.Comp.Client, FireDAC.Stan.Def, FireDAC.Stan.Async, FireDAC.DApt;

type
  [TestFixture]
  TOrderTests = class
  private
    FConnection: TFDConnection;
    procedure SetupDatabaseConnection;
  public
    [Setup]
    procedure Setup;

    [TearDown]
    procedure TearDown;

    [Test]
    procedure TestCalculateTotal_ValidOrder;

    [Test]
    procedure TestCalculateTotal_OrderWithoutItems;

    [Test]
    procedure TestCalculateTotal_InvalidOrderID;
  end;

implementation

procedure TOrderTests.Setup;
begin
  SetupDatabaseConnection;
end;

procedure TOrderTests.TearDown;
begin
  FConnection.Close;
  FConnection.Free;
end;

procedure TOrderTests.SetupDatabaseConnection;
begin
  FConnection := TFDConnection.Create(nil);
  FConnection.DriverName := 'MSSQL'; // ou outro driver, dependendo do seu banco de dados
  FConnection.Params.Database := 'OrderDB';  // Nome do banco
  FConnection.Params.UserName := 'sa';       // Usuário
  FConnection.Params.Password := 'password'; // Senha
  FConnection.Connected := True;
end;

procedure TOrderTests.TestCalculateTotal_ValidOrder;
var
  FDQuery: TFDQuery;
  Total: Currency;
begin
  FDQuery := TFDQuery.Create(nil);
  try
    FDQuery.Connection := FConnection;
    FDQuery.SQL.Text := 'DECLARE @Total DECIMAL(18,2); EXEC @Total = CalculateOrderTotal :OrderID; SELECT @Total AS Total;';
    FDQuery.ParamByName('OrderID').AsInteger := 1; // Use um OrderID válido para o teste
    FDQuery.Open;

    Total := FDQuery.FieldByName('Total').AsCurrency;

    // Verifica se o valor total do pedido está correto (baseado no pedido 1)
    Assert.AreEqual(100.50, Total); // Exemplo de valor esperado
  finally
    FDQuery.Free;
  end;
end;

procedure TOrderTests.TestCalculateTotal_OrderWithoutItems;
var
  FDQuery: TFDQuery;
  Total: Currency;
begin
  FDQuery := TFDQuery.Create(nil);
  try
    FDQuery.Connection := FConnection;
    FDQuery.SQL.Text := 'DECLARE @Total DECIMAL(18,2); EXEC @Total = CalculateOrderTotal :OrderID; SELECT @Total AS Total;';
    FDQuery.ParamByName('OrderID').AsInteger := 999; // Use um OrderID que não tem itens

    FDQuery.Open;

    Total := FDQuery.FieldByName('Total').AsCurrency;

    // Verifica se o valor total é 0 para um pedido sem itens
    Assert.AreEqual(0, Total);
  finally
    FDQuery.Free;
  end;
end;

procedure TOrderTests.TestCalculateTotal_InvalidOrderID;
var
  FDQuery: TFDQuery;
begin
  FDQuery := TFDQuery.Create(nil);
  try
    FDQuery.Connection := FConnection;
    FDQuery.SQL.Text := 'DECLARE @Total DECIMAL(18,2); EXEC @Total = CalculateOrderTotal :OrderID;';
    FDQuery.ParamByName('OrderID').AsInteger := -1;

    try
      FDQuery.Open;
      Assert.Fail('An error should have occurred for an invalid OrderID.');
    except
      on E: Exception do
      begin
        Assert.IsTrue(Pos('invalid', LowerCase(E.Message)) > 0, 'Error message did not contain "invalid"');
      end;
    end;
  finally
    FDQuery.Free;
  end;
end;

initialization
  TDUnitX.RegisterTestFixture(TOrderTests);
end.
